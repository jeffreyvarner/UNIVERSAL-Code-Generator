//
//  VLTransformationCanvasView.m
//  Universal
//
//  Created by Jeffrey Varner on 2/14/13.
//  Copyright (c) 2013 Varnerlab. All rights reserved.
//

#import "VLTransformationCanvasView.h"
#import "VLTransformationCanvasViewController.h"
#import "VLTransformCanvasWidgetViewController.h"

@interface VLTransformationCanvasView ()

// Private lifecycle methods -
-(void)setup;
-(void)cleanMyMemory;

// private props -
@property (retain) NSView *mySelectedWidgetView;

@end

@implementation VLTransformationCanvasView

// synthesize -
@synthesize myViewController = _myViewController;
@synthesize mySelectedWidgetView = _mySelectedWidgetView;

- (id)initWithFrame:(NSRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        
        // initialize -
        [self setup];
    }
    
    return self;
}

-(void)dealloc
{
    [self cleanMyMemory];
    [super dealloc];
}

- (void)drawRect:(NSRect)dirtyRect
{
    // Drawing code here.
}

#pragma mark - dragging destination protocal methods
- (NSDragOperation)draggingEntered:(id < NSDraggingInfo >)sender
{
    NSLog(@"Dragging entered method called...");
    
    return NSDragOperationCopy;
}

- (BOOL)performDragOperation:(id <NSDraggingInfo>)sender
{
    
    NSPasteboard *pboard;
    pboard = [sender draggingPasteboard];
    
    if ([[pboard types] containsObject:NSStringPboardType]==YES)
    {
        // get the view controller -
        if ([self myViewController]!=nil)
        {
            [[self myViewController] addTransformationWidgetViewControllerToCanvas:sender];
        }
        
        // return -
        return YES;
    }
    
    // default -
    return NO;
}

#pragma mark - mouse handling events
-(BOOL)acceptsFirstResponder
{
    return YES;
}

-(void)mouseDown:(NSEvent *)theEvent
{
    NSPoint clickLocation;
    BOOL itemHit = NO;
    
    // convert the click location into the view coords
    clickLocation = [self convertPoint:[theEvent locationInWindow]
                              fromView:nil];
    
    // did the click occur in the item?
    itemHit = [self isPointInItem:clickLocation];
    
    // Yes it did, note that we're starting to drag
    if (itemHit)
    {
        // ok, so we selected an item -
        // is this a control click?
        if ([theEvent modifierFlags] & NSControlKeyMask)
        {
            
        }
        else
        {
            // flag the instance variable that indicates
            // a drag was actually started (w/no control mask)
            _isDraggingWidget = YES;
            
            // store the starting click location;
            _myLastDragLocation = clickLocation;
            
            // set the cursor to the closed hand cursor
            // for the duration of the drag
            [[NSCursor closedHandCursor] push];
        }
    }
}

-(void)mouseUp:(NSEvent *)theEvent
{
    // ok, we are done dragging
    _isDraggingWidget = NO;
    
    // finished dragging, restore the cursor
    [NSCursor pop];
    
    // the item has moved, we need to reset our cursor
    // rectangle
    [[self window] invalidateCursorRectsForView:self];
    
    // go back to original border -
    NSView *view = self.mySelectedWidgetView;
    
    // set the gray border -
    CGColorRef grey = CGColorCreateGenericRGB(0.0, 0.0, 0.0, 1.0);
    [[view layer] setBorderWidth:1.0f];
    [[view layer] setCornerRadius:5.0f];
    [[view layer] setBorderColor:grey];
    CGColorRelease(grey);

    // release the selected view -
    self.mySelectedWidgetView = nil;
}

-(void)mouseDragged:(NSEvent *)theEvent
{
    if (_isDraggingWidget == YES)
    {
        NSPoint newDragLocation=[self convertPoint:[theEvent locationInWindow]
                                          fromView:nil];
        
        
        // offset the pill by the change in mouse movement
        // in the event
        [self offsetLocationByX:(newDragLocation.x-_myLastDragLocation.x)
                           andY:(newDragLocation.y-_myLastDragLocation.y)];
        
        // save the new drag location for the next drag event
        _myLastDragLocation = newDragLocation;
        
        // set the origin on my selected view -
        NSRect myFrame = [[self mySelectedWidgetView] frame];
        myFrame.origin = _myLastDragLocation;
        [[self mySelectedWidgetView] setFrame:myFrame];
        
        // support automatic scrolling during a drag
        // by calling NSView's autoscroll: method
        [[self mySelectedWidgetView] autoscroll:theEvent];
    }
}

- (void)offsetLocationByX:(float)x andY:(float)y
{
    // tell the display to redraw the old rect
    [self setNeedsDisplayInRect:[self calculatedItemBounds]];
    
    // since the offset can be generated by both mouse moves
    // and moveUp:, moveDown:, etc.. actions, we'll invert
    // the deltaY amount based on if the view is flipped or
    // not.
    int invertDeltaY = [self isFlipped] ? -1: 1;
    
    _myCurrentLocation.x = _myCurrentLocation.x+x;
    _myCurrentLocation.y = _myCurrentLocation.y+y*invertDeltaY;
    
    // invalidate the new rect location so that it'll
    // be redrawn
    [self setNeedsDisplayInRect:[self calculatedItemBounds]];
}


// -----------------------------------
// Hit test the item
// -----------------------------------
- (BOOL)isPointInItem:(NSPoint)testPoint
{
    BOOL itemHit = NO;
    
    // grab the item -
    NSView *view = [[self myViewController] widgetForTransformationCanvas:self atPosition:testPoint];
    if (view!=nil)
    {
        itemHit = YES;
        self.mySelectedWidgetView = view;
        
        // set the gray border -
        CGColorRef grey = CGColorCreateGenericRGB(0.5, 0.5, 0.5, 0.3);
        [[view layer] setBorderWidth:1.0f];
        [[view layer] setCornerRadius:5.0f];
        [[view layer] setBorderColor:grey];
        CGColorRelease(grey);
    }
    
    return itemHit;
}

- (NSRect)calculatedItemBounds
{
    NSRect calculatedRect;
    
    // calculate the bounds of the draggable item
    // relative to the location
    calculatedRect.origin = _myCurrentLocation;
    
    // the example assumes that the width and height
    // are fixed values
    calculatedRect.size.width = 100.0f;
    calculatedRect.size.height = 100.0f;
    
    return calculatedRect;
}

#pragma mark - private lifecycle
-(void)setup
{
    // initially we are *not* dragging -
    _isDraggingWidget = NO;
    
    // Register for drag -
    [self registerForDraggedTypes:[NSArray arrayWithObject:NSStringPboardType]];
}

-(void)cleanMyMemory
{
    // Clean my iVars -
    self.myViewController = nil;
    self.mySelectedWidgetView = nil;
    
    // Remove me from the NSNotificationCenter -
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}


@end
